#  实习总结

## 项目总结

1. 评价系统星级标签接入投放
需求背景：标签信息配置、国家城市星级标签配置接入投放功能，国家默认兜底配置。
主要职责：测试BR\AU等国家及产品线乘客侧五星标签展示和提交功能的接口返回与线上是否一致。
2. 俄罗斯车牌展示&车牌支持富文本
需求背景：对俄罗斯车牌进行格式化处理，并针对不同国家的车牌可能存在的特殊样式，通过提供通用性能力解决。
主要职责：测试接口新增字段在正常或者异常情况能否显示正确。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyrblj0eoj319q0jktc7.jpg" alt="image-20200721181152683" style="zoom: 45%;" />

## 学习记录

### 测试流程

1. 需求评审
2. 写准入case
3. 写测试case
4. case评审(改动点、风险点)
5. 部署测试环境
6. 测试(执行测试case、提bug)
7. 准出
8. 跟进上线

### 测试方法 & 设计测试用例

黑盒测试

* 把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。
* 测试目标
  * 是否有不正确或遗漏的功能？
  * 在接口上，输入是否能正确的接受？能否输出正确的结果？
  * 是否具有数据结构错误或外部信息（例如数据文件）访问错误？
  * 性能上是否能够满足要求？
  * 是否有初始化和终止性错误？
* 测试方法
  * 等价类划分法
    * 将程序所有可能的输入数据划分为若干个等价类，然后从每个部分中选取具有代表性的数据当做测试用例；
    * 测试用例由**有效**等价类和**无效**等价类的代表数据组成。
  * 边界值分析法
    * 对程序**输入或输出的边界值**进行测试。
  * 因果图法
    * 根据输入条件的组合、约束关系和输出条件的因果关系，分析输入条件的各种组合情况，从而设计测试用例；
    * 它适合于检查程序**输入条件的各种组合**情况。

白盒测试

* 把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序状态，确定实际状态是否和预期的状态一致。
* 测试目标
  * 对程序模块的所有独立的执行路径至少测试一遍
  * 对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍
  * 在循环的边界和运行的边界内执行循环体
  * 测试内部数据的有效性
* 测试方法
  * 程序结构分析
    * 根据源代码可以首先绘制程序的流程图，然后根据流程图分析程序的结构。
  * 逻辑覆盖
    * 根据程序的内部结构，对所有的路径进行测试，是一种穷举路径的测试方法。
  * 基本路径测试
    * 根据程序的逻辑判断，分析程序中的路径，再进行用例的设计。

### 接口测试

1. 如何设计测试用例？

接口测试一般考虑入参形式的变化和接口的业务逻辑，一般设计接口测试用例采用等价类、边界值、场景法居多。
接口测试设计测试用例的思路如下：

* 接口业务逻辑测试?(正例)
  接口逻辑测试是指根据业务逻辑、输入参数、输出值的描述，对正常输入情况下所得的输出值
  是否正确的测试，也就是测试对外提供的接口服务是否正常工作。
* 模块接口测试(反例)
  模块接口测试是为了保证数据的安全及程序在异常情况下的逻辑的正确性而进行的测试。
  模块接口测试的主要包括以下几个方面：
  * 鉴权码token异常(鉴权码为空<没有鉴权码>,错误的鉴权码,过期的鉴权码)。
  * 其他参数异常。
    * 必填项检查
    * 参数的长度、类型、格式异常：
              常规参数：(数字、字符串、日期)
              参数长度：6-18位。或身份证、电话的长度。
              参数类型：数字(精度)，字母，中文，带空格的参数，特殊字符。
              日期格式：日期：年月日，年月日时分秒，日期格式(包括/,-,:等)。
    * 错误码异常覆盖。

2. 接口组成

请求地址、请求方法、请求参数（入参和出参）组成，部分接口有请求头header。

3. header请求头和入参都是发送到服务器他们有什么区别呢？

* header里存放的参数一般存放的是一些校验信息，比如cookie，它是为了校验这个请求是否有权限请求服务器，如果有，它才能请求服务器，然后把请求地址连同入参一起发送到服务器，然后服务器会根据地址和入参来返回出参。
* 也就是说，服务器是先接受header信息进行判断该请求是否有权限请求，判断有权限后，才会接受请求地址和入参的。

### 自动化测试

* 使用dws自动化测试框架

  * api层自动化测试框架，能支持api层的测试，包括接口返回值等各种验证。
  * 这是基于python的unittest的扩展。

* case编写

  1. 在对应的文件更新自己的测试账号；

  2. 根据接口的触发流程写入需要调用的接口；

  3. 对已存在的字段，进行替换；对未存在的字段，进行新增；

  4. 对于要校验的返回值进行断言处理。

     > 断言设置不仅要设置改动点的返回，还要设置涉及到改动点的返回是否符合预期，出问题才能定位的比较准确。

# 实验室项目总结

## 项目介绍

## 我的贡献

# Python相关

## 数据类型

### 基本数据类型

数字int、布尔值bool、字符串str、列表list、元组tuple、字典dict等

### 列表和元组的区别

* 列表是动态数组，它们不可变且可以重设长度(改变其内部元素的个数)。
* 元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。

### 可变类型和不可变类型

* 可变类型（mutable）：列表，字典
* 不可变类型（unmutable）：数字，字符串，元组

这里的可变不可变，是指**内存中的那块内容（value）是否可以被改变**。
如果是不可变类型，在对对象本身操作的时候，必须在内存中新申请一块区域(因为老区域不可变)。
如果是可变类型，对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的address会保持不变，但区域会变长或者变短。

不可变类型有什么好处？
如果数据是不可变类型，当我们把数据传给一个不了解的API时，可以确保我们的数据不会被修改。

## 深拷贝和浅拷贝

* 深拷贝
  * 创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）
  * 完全切片方法；工厂函数，如list()；copy模块的copy()函数
* 浅拷贝
  * 创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）
  * copy模块的deep.deepcopy()函数

## 垃圾回收机制

* 对象的引用计数

  * Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
    * 引用计数增加的情况：
      * 一个对象分配一个新名称
      * 将其放入一个容器中（如列表、元组或字典）

    * 引用计数减少的情况：
      * 使用del语句对对象别名显示的销毁
      * 引用超出作用域或被重新赋值

## lambda函数

通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。

* 定义lambda函数的形式如下：

  * labmda 参数：表达式lambda函数默认返回表达式的值。

  * ```python
    # lambda [arguments]:expression
    a = lambda x,y:x+y
    ```

* lambda函数也可以赋值给一个变量。

* lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。

# HTTP

## get 和 post 的区别

- 根本的区别：GET是用于获取数据，不会对数据进行更改；而POST是用于传输数据，会对数据进行更改。
- GET使用URL传参，数据放在URL里面，在浏览器中是可见的，非常不安全；而POST是将数据放在请求体中，用户不可见，相对比较安全。
- GET传递的数据是放在URL里面的，虽然HTTP协议规范中没有对URL长度进行限制，但是由于浏览器及服务器的限制，所以GET的URL会有长度上的限制，而POST可发送的数据没有长度限制。

## 状态码

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

## HTTP与HTTPS

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了**加密（防窃听）**、**认证（防伪装）**和**完整性保护（防篡改）**。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh00tknagnj30un09l0uo.jpg" alt="img" style="zoom:50%;" />

> HTTP端口 80
> HTTPS端口443

### 加密

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;

- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh00y6wxjlj30u02650vm.jpg" alt="img" style="zoom: 25%;" />

### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh02s7vdgtj30m80gjdgw.jpg" alt="img" style="zoom:60%;" />

### 完整性保护

SSL 提供报文**摘要功能**来进行完整性保护。

## 输入一个网址到显示网页的过程

1. 在客户端浏览器中输入网址URL；
2. 发送到DNS(域名服务器)获得域名对应的WEB服务器的IP地址；
3. 客户端浏览器与WEB服务器建立TCP(传输控制协议)连接；
4. 客户端浏览器向对应IP地址的WEB服务器发送相应的HTTP或HTTPS请求；
5. WEB服务器响应请求，返回指定的URL数据或错误信息；
6. 客户端浏览器下载数据，解析HTML源文件，解析完成后，在浏览器中显示基础的页面；
7. 分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh02j2a8v6j30fy0cidjh.jpg" alt="image-20200722212545866" style="zoom: 80%;" />

### DNS域名系统工作原理

1. 查询浏览器、操作系统**缓存**；
2. 请求**本地域名服务器**；
3. 本地域名服务器未命中缓存，其请求**根域名服务器**；
4. 根域名服务器返回所查询域的**主域名服务器**（主域名、顶级域名，如com、cn）；
5. 本地域名服务器请求主域名服务器，获取该域名的 **名称服务器**（域名注册商的服务器）；
6. 本地域名服务器向 名称服务器 请求 **域名-IP 映射**；
7. 缓存解析结果。

### 客户端向服务器发起http请求时的请求信息

1. 请求方法URI协议/版本
2. 请求头(有关的客户端环境和请求正文的有用信息)
3. 请求正文(客户提交的查询字符串信息：)

##Cookie、Session

* Cookie保存在**客户端浏览器**中，而Session保存在**服务器**上。
* Cookie机制是通过检查客户身上的**“通行证”**来确定客户身份，Session机制是通过检查服务器上的**“客户明细表”**来确认客户身份。

## 短连接、长连接

* 短连接
  * 连接->传输数据->关闭连接 
  * HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
* 长连接
  * 连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接
  * 多是客户端关闭连接

# MySQL

## 使用的索引

* Hash索引
  * 底层原理：哈希表
* B+树索引
  * 底层原理：多路平衡查找树

## 事务

### 定义

一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务)。

### 事务四大特征(ACID)

* 原子性(A)：事务是最小单位，不可再分。
* 一致性(C)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败。
* 隔离性(I)：事务A和事务B之间具有隔离性。
* 持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)。

### 事务提交

`commit;`(让虚拟的效果真实产生)

### 事务手动回滚

`rollback;`（让虚拟的效果撤销）

### 事务的隔离性

* read uncommitted
  * 读未提交的
  * A事务已执行，但未提交；B事务查询到A事务的更新后数据；A事务回滚；---出现脏数据
* read committed
  * 读已经提交的
  * A事务执行更新；B事务查询；A事务又执行更新；B事务再次查询时，前后两次数据不一致；---不可重复读
* repeatable read
  * 可重复读
  * A事务无论执行多少次，只要不提交，B事务查询值都不变；B事务仅查询B事务开始时那一瞬间的数据快照。
* serializable
  * 串行化
  * 不允许读写并发操作，写执行时，读必须等待。

> mysql默认隔离级别是repeatable read

## 三大设计范式

* 第一范式：数据中所有字段都是不可分割的原子值。
* 第二范式：必须满足第一范式的前提下，除主键外的每一列都必须完全依赖于主键。
* 第三范式：必须满足第二范式，除主键列外的其他列之间不能有传递依赖关系。

## 查询

### 连接查询

* 内连接

  * inner join 或者 join
  * 两张表中的数据，通过某个字段相等，查询出相关记录数据，用 on… 表示条件。

  ![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh0088pu9mj30640340sj.jpg)

* 外连接

  * 左连接：left join

    * 会把左边表里面的所有数据取出来，而右边表数据如果有相等的，就显示出来，如果没有，就补 NULL。

      ![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh008kq78sj307l032744.jpg)

  * 右连接：right join

    * 会把右边表里面的所有数据取出来，而左边表数据如果有相等的，就显示出来，如果没有，就补 NULL。

    ![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh008oukaej306g0393yb.jpg)

### 查询语句的执行顺序

* 查询语句书写顺序：select-from-where-group by-having-order by-limit

* 查询语句执行顺序：from-where-group by-having-select-order by-limit

> from：决定从哪儿获取数据
> where，group by，having：决定决定显示那几行
> select：决定显示的列
> order by：对列进行排序
> limit：决定获取哪些数据

### 面试题

- 学生表student(id,name)
- 课程表course(id,name)
- 学生课程表student_course(sid,cid,score)

1. 查询student表中重名的学生，结果包含id和name，按name,id升序。

   * 需要查询某一列重复的行，一般通过**group by**(有重复的列)然后取**count>1**的值。 

   * **order by** 默认升序排列

     ```mysql
     select id, name from student where name in (
       select name from student group by name	# 分组
     having count(*) > 1	#条件
     ) order by name;
     ```
     

   > count(*)
   > 返回表中的记录数(包括所有列)，相当于**统计表的行数**(不会忽略列值为NULL的记录)
   >
   > count(1)
   > 忽略所有列，1表示一个固定值，也可以用count(2)、count(3)代替(不会忽略列值为NULL的记录)
   >
   > count(列名)
   > 返回列名指定列的记录数，列值为NULL的记录不统计在内。
   >
   > count(distinct 列名)
   > 只包括列名指定列，返回指定列的**不同值**的记录数，列值为NULL的记录不统计在内。

   

2. 在student_course表中查询平均分不及格的学生，列出学生id和平均分。

   * **where子句中不能用聚集函数作为条件表达式，但是having短语可以**；

   * where和having的区别在于对用对象不同，where只能写在group by前边，要想在后边加限制条件，应该使用having关键字，即**where只能写在group by前边，要想在后边加限制条件，应该使用having关键字。**

      ```mysql
     select sid, avg(score) as avg_score from student_course group by sid 
     	having avg_score < 60;
      ```

   > 聚合函数是用来做纵向运算的函数
   >
   > count()：统计指定列不为null的记录行数。
   > max()：  计算指定列的最大值
   > min()：  计算指定列的最小值
   > sum()： 计算指定列的数值和
   > avg()：  计算指定列的平均值
   >
   > **注：凡是和聚合函数同时出现的列名，则一定要写在group by之后。**

   

3. 在student_course表中查询每门课成绩都不低于80的学生id。

   * ```mysql
     select distinct sid from student_cource where sid in(
       select sid from student_cource where score > 80);
     ```

4. 总成绩最高的学生，结果列出学生id和总成绩。

   * **order by、limit**

     ```mysql
     select sid, sum(score) as sum_score from student_cource group by sid 
     	order by sum_score desc limit 1;
     ```

   > limit用来限制查询结果的起始行，以及总行数.

   

5. 在student_course表查询课程1成绩第2高的学生，如果第2高的不止一个则列出所有的学生。

   * 查询 **第N大数** 的问题

     ```mysql
     select * from student_course where cid = 1 and score = (
       # 查出第2高的成绩
       select score from student_course where cid = 1 group by score order by score desc limit 1, 1);
     ```

## MySQL与Redis的区别

* 类型上
  * 从类型上来说，mysql是关系型数据库，redis是缓存数据库。

* 作用上
  * mysql用于持久化的存储数据到**硬盘**，功能强大，但是读取速度较慢。
  * redis用于存储使用较为频繁的数据到**缓存**中，读取速度快。

# 计算机网络

## 计算机网络体系结构

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh02rwaro2j30k60gi0tc.jpg" alt="img" style="zoom:50%;" />

* 每一层的作用：
  * 物理层：通过媒介传输比特，确定机械及电气规范（比特Bit）（中继器，集线器，网关）
  * 数据链路层：将比特封装成帧和点到点的传递（帧Frame）（网桥，交换机）
  * 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）（路由器）
    * 协议：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP
  * 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    * 协议：TCP、UDP
  * 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    * 协议：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

## TCP三次握手

### 过程

假设 A 为客户端，B 为服务器端。

1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求；
2. A 向 B 发送连接请求报文；
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文；
4. A 收到 B 的连接确认报文后，还要向 B 发出确认；
5. B 收到 A 的确认后，连接建立。

### 三次握手的原因

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## TCP四次挥手

### 过程

1. A 发送连接释放报文；
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
3. 当 B 不再需要连接时，发送连接释放报文；
4. A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接；
5. B 收到 A 的确认后释放连接。

### 四次挥手的原因

客户端发送了连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

#### 为什么要TIME_WAIT

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## TCP和UDP的区别

1. TCP面向连接，UDP无连接；
2. TCP开销比UDP小；
3. TCP提供可靠的服务，UDP不保证可靠交付；
4. 每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。

## TCP如何保证数据的可靠传输

4种拥塞控制算法：慢启动，拥塞避免，快速重传和快速恢复。

1. 针对数据包丢失或者出现的定时器**超时重传**机制；
2. 针对数据包到达接收端主机顺序乱掉的顺序控制、对失序**数据进行重新排序**，然后才交给应用层；
3. 针对高效传输数据包的**流动窗口控制**；
4. 针对避免网络拥堵时候的**流量控制**；
5. 针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的**慢启动算法**和**拥塞控制**。

# 操作系统

## 进程间通信的方式

* 消息传递（管道、消息队列、FIFO）
* 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
* 共享内存（匿名的和具名的，eg:channel）
* 远程过程调用(RPC)

## 进程和线程

- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，**进程是系统进行资源分配和调度的一个独立单位**。
- **线程是进程的一个实体，是CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位。

### 进程和线程的关系

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。**线程是操作系统可识别的最小执行和调度单位**。
- 资源分配给**进程**，同一进程的所有线程**共享**该进程的所有资源。
- 真正在处理机上运行的是**线程**。
- 线程在执行过程中，需要协作同步。不同进程的线程间要利用**消息通信**的办法实现同步。

### 进程和线程的区别

- 进程有自己的独立**地址空间**，线程没有；
- 进程是**资源分配**的最小单位，线程是**CPU调度**的最小单位；
- 进程和线程通信方式不同；
  - **同一进程下的线程共享数据**(比如全局变量，静态变量)，线程通过这些数据来通信；
  - 而进程之间的通信只能通过**进程通信**的方式进行。
- 进程上下文切换**开销大**，线程**开销小**；
- 一个进程挂掉了**不会影响**其他进程，而线程挂掉了**会影响**其他线程；

# 补充

## Linux如何查看端口状态

* 查看哪些端口被打开：`netstat -anp`

* 关闭某个端口：`kill -9 PID` (PID：进程号)

  ```sh
  # 例如要关闭22号端口：
  
  $ netstat -anp | grep :22
  # 返回
  tcp 0  0 0.0.0.0:22   0.0.0.0:*  LISTEN  988/sshd
  
  # 如此，知道了22号端口对应的进程ID 988，只要kill掉该进程即可关闭该端口：
  $ kill 988
  ```

## Nginx

### 什么是Nginx?

Nginx是一个web服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。

### 反向代理服务器是什么?

我们访问互联网上的服务时，大多数时，客户端并不是直接访问到服务端的，而是客户端首先请求到反向代理，反向代理再转发到服务端实现服务访问，通过反向代理实现路由/负载均衡等策略。这样在服务端拿到的客户端IP将是反向代理IP，而不是真实客户端IP，因此需要nginx反向代理实现获取用户真实ip

```nginx
# 客户端访问服务端的数据流走向
client(172.25.0.1) --> ADSL(192.168.0.1)--> cdn(10.0.0.1) --> SLB(反向代理)11.0.0.1 --> server(nginx)12.0.0.1
```

反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层，提高了安全性。

### Nginx如何处理HTTP请求？

Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。

# 面试模拟

1. 自我介绍

2. 介绍一下实验室的项目，你都做了什么？

3. 介绍一下实习的项目，你都做了什么？

4. 测试流程、测试方法？

5. 自动化测试的流程、case如何编写？

   ...

