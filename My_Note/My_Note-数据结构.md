# 数组和链表的区别

## 内存中的存储

数组：连续、顺序存储

> 在Python语言中，没有直接使用数组这个概念，而是用**列表(list)**和**元组(tuple)**这两种集合，它们本质上都是对数组的封装。
>
> 其中**列表**是一个**动态可扩展**的数组，支持任意的添加、删除、修改元素；
> 而**元组**是一个**不可变**集合，一旦创建就不再支持修改。s

链表：非连续、非顺序存储

## 时间复杂度

|      | 查找 | 更新 | 插入 | 删除 |
| ---- | ---- | ---- | ---- | ---- |
| 数组 | O(1) | O(1) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(1) |



# 栈和队列

## 物理结构和逻辑结构

|                    | 线性结构         | 非线性结构       |
| ------------------ | ---------------- | ---------------- |
| 逻辑结构(精神层面) | 顺序表、栈、队列 | 树、图           |
|                    | **顺序存储结构** | **链式存储结构** |
| 物理结构(物质层面) | 数组             | 链表             |

## 实际应用

栈：历史的**回溯**（逆流而上）

队列：历史的**回放**（从头到尾）

# 哈希表

## 哈希函数

哈希表在本质上也是一个**数组**。通过**哈希函数**实现key和数组下标的转换。

> 在Python中，哈希表对应的集合叫作**字典(dict)**。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggxm440ob6j30p60cgjxp.jpg" alt="image-20200720174321392" style="zoom:67%;" />

哈希函数如何转化成数组的下标？

* 按照数组长度进行**取模运算**：index = hash[key] % size

  > Python 中采取的是**位运算**。

## 哈希表的读写

### 写入(put)

在哈希表中插入新的键值对(entry)

1. 通过哈希函数，将key转化成对应数组下标 i ；
2. 如果数组下标 i 对应的位置没有元素，就把这个entry填充到数组下标的 i 的位置。

但是，由于数组长度是有限的，当插入的entry越来越多时，不同的key通过哈希函数获得的下标有可能是相同的。
这种情况，就叫做**哈希冲突**。

**解决哈希冲突的方法：**

* **开放寻址法**
  * 当一个key通过哈希函数获得对应的数组下标已被占用时，我们就寻找下一个空档位置。
* **链表法**
  * 哈希数组的每一个元素不仅是一个entry对象，还是一个链表的头节点。每一个entry对象通过next指针指向它的下一个entry节点。当新来的entry映射到与之冲突的数组位置时，只需要插入对应的链表中即可。

> Python中的dict采用的是开放寻址法。

### 读取(get)

给定key，在哈希表中查找对应的value

1. 通过哈希函数，将key转化成对应数组下标 i ；
2. 找到数组下标 i 所对应的元素
   * 如果找到的元素的key与给定的key一致，那么就找到了。
   * 如果找到的元素的key与给定的key不一致，由于数组的每个元素都与一个链表对应，那么就顺着链表慢慢往下找，看看能否找到与key相匹配的节点。

# 树

## 二叉树

### 内存中的存储

链式存储

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyoqcb40mj30ok0lcqd6.jpg" alt="image-20200721164229504" style="zoom: 50%;" />

数组存储

* **定位父节点的左孩子、右孩子**
  * 父节点下标：parent
  * 左孩子下标：parent \* 2 + 1，右孩子下标：parent \* 2 + 2

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyor5zqvqj30oc0l8jxb.jpg" alt="image-20200721164329187" style="zoom:50%;" />

​		

### 应用

查找操作

* 二叉查找树
  * 如果左子树不为空，则左子树上所有节点的值均小于根节点的值。
  * 如果右子树不为空，则右子树上所有节点的值均大于根节点的值。
  * 左、右子树也都是二叉查找树。

维持相对顺序

## 二叉堆

### 类型

本质是**完全二叉树**，使用**数组**来存储。分为两种类型：

* 最大堆
  * 堆顶是整个堆中的**最大元素**。
  * 任何一个父节点的值，都大于或等于它的左孩子、右孩子节点的值。
* 最小堆
  * 堆顶是整个堆中的**最小元素**。
  * 任何一个父节点的值，都小于或等于它的左孩子、右孩子节点的值。

### 二叉堆的操作

* 插入：插入位置是完全二叉树的**最后一个位置**。
* 删除：删除的是处于**堆顶**的节点。
* 构建二叉堆：把一个无序的二叉树调整成二叉堆。本质就是让**所有非叶子节点依次下沉**。

## 优先队列

### 最大优先队列

* 无论入队顺序如何，都是当前**最大**的元素优先出队。
* 基于**最大堆**实现。
  * 入队：二叉堆的插入(树尾)
  * 出队：二叉堆的删除(堆顶节点)

### 最小优先队列

* 无论入队顺序如何，都是当前**最小**的元素优先出队。
* 基于**最小堆**实现。
  * 入队：二叉堆的插入(树尾)
  * 出队：二叉堆的删除(堆顶节点)