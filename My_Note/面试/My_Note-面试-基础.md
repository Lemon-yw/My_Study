# 自我介绍

我目前在北京邮电大学即将开学读研三，所在实验室的主要方向是光网络及卫星通信相关，我在研究生期间主要的研究方向是强化学习与数据中心光网络结合的方向。今年6-8月期间在滴滴公司国际化业务技术部远程实习，主要工作是进行服务端的测试工作，涉及的主要方面是功能测试、接口测试以及自动化case的编写等。

#  实习总结

## 项目总结

1. 俄罗斯车牌展示&车牌支持富文本
  需求背景：对俄罗斯车牌进行格式化处理，并针对不同国家的车牌可能存在的特殊样式，通过提供通用性能力解决。
  主要职责：：测试接口新增字段在正常或者异常情况能否显示正确，并保证字段格式的设置与端正常交互。

2. 国际化闪送支持发多单

  需求背景：闪送用户发送完一单之后，可以返回首页继续发新的订单。

  改动点：

  1. 发单接口，发单拦截支持闪送业务发多单
  2. 在首页显示正在进行的闪送订单接口，增加闪送发多单的模板

  主要职责：测试命中发多单场景的主流程是否正常，验证各触发点的逻辑是否符合需求及异常状况下的处理。



## 学习记录

### 测试流程

QA就测试RD开发的分支代码，首先看一下代码改动点，看一下改动是否符合需求，然后看一下改动代码是否有语法错误，然后进行接口测试，测试逻辑是否合理，返回是否正确，考虑正常和异常场景，以及整体代码的覆盖度。

1. 需求评审
2. 写准入case
3. 写测试case
4. case评审(改动点、风险点)
5. 部署测试环境
6. 测试(执行测试case、提bug、回归)
7. 准出
8. 跟进上线

学业务 -> 理解需求 -> 制定测试计划 -> 写case -> 执行测试 -> 报bug -> 回归测试 -> 做测试总结

### 测试方法 & 设计测试用例

黑盒测试

* 把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。
* 测试目标
  * 是否有不正确或遗漏的功能？
  * 在接口上，输入是否能正确的接受？能否输出正确的结果？
  * 是否具有数据结构错误或外部信息（例如数据文件）访问错误？
  * 性能上是否能够满足要求？
  * 是否有初始化和终止性错误？
* 测试方法
  * 等价类划分法
    * 将程序所有可能的输入数据划分为若干个等价类，然后从每个部分中选取具有代表性的数据当做测试用例；
    * 测试用例由**有效**等价类和**无效**等价类的代表数据组成。
  * 边界值分析法
    * 对程序**输入或输出的边界值**进行测试。
  * 因果图法
    * 根据输入条件的组合、约束关系和输出条件的因果关系，分析输入条件的各种组合情况，从而设计测试用例；
    * 它适合于检查程序**输入条件的各种组合**情况。

白盒测试

* 把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序状态，确定实际状态是否和预期的状态一致。
* 测试目标
  * 对程序模块的所有独立的执行路径至少测试一遍
  * 对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍
  * 在循环的边界和运行的边界内执行循环体
  * 测试内部数据的有效性
* 测试方法
  * 程序结构分析
    * 根据源代码可以首先绘制程序的流程图，然后根据流程图分析程序的结构。
  * 逻辑覆盖
    * 根据程序的内部结构，对所有的路径进行测试，是一种穷举路径的测试方法。
  * 基本路径测试
    * 根据程序的逻辑判断，分析程序中的路径，再进行用例的设计。

**设计测试用例**

https://blog.csdn.net/qq_43669007/article/details/107347490?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf

测试思路：主攻功能（从正面+负面覆盖），然后覆盖非功能（包括界面、兼容性、性能、安全、易用性五个方面）。

### 接口测试

1. 如何设计测试用例？

接口测试一般考虑入参形式的变化和接口的业务逻辑，一般设计接口测试用例采用等价类、边界值、场景法居多。
接口测试设计测试用例的思路如下：

* 接口业务逻辑测试?(正例)
  接口逻辑测试是指根据业务逻辑、输入参数、输出值的描述，对正常输入情况下所得的输出值
  是否正确的测试，也就是测试对外提供的接口服务是否正常工作。
* 模块接口测试(反例)
  模块接口测试是为了保证数据的安全及程序在异常情况下的逻辑的正确性而进行的测试。
  模块接口测试的主要包括以下几个方面：
  * 鉴权码token异常(鉴权码为空<没有鉴权码>,错误的鉴权码,过期的鉴权码)。
  * 其他参数异常。
    * 必填项检查
    * 参数的长度、类型、格式异常：
              常规参数：(数字、字符串、日期)
              参数长度：6-18位。或身份证、电话的长度。
              参数类型：数字(精度)，字母，中文，带空格的参数，特殊字符。
              日期格式：日期：年月日，年月日时分秒，日期格式(包括/,-,:等)。
    * 错误码异常覆盖。

2. 接口组成

请求地址、请求方法、请求参数（入参和出参）组成，部分接口有请求头header。

3. header请求头和入参都是发送到服务器他们有什么区别呢？

* header里存放的参数一般存放的是一些校验信息，比如cookie，它是为了校验这个请求是否有权限请求服务器，如果有，它才能请求服务器，然后把请求地址连同入参一起发送到服务器，然后服务器会根据地址和入参来返回出参。
* 也就是说，服务器是先接受header信息进行判断该请求是否有权限请求，判断有权限后，才会接受请求地址和入参的。

### 自动化测试

* 使用dws自动化测试框架

  * api层自动化测试框架，能支持api层的测试，包括接口返回值等各种验证。
  * 这是基于python的unittest的扩展。

* case编写

  1. 在对应的文件更新自己的测试账号；

  2. 根据接口的触发流程写入需要调用的接口；

  3. 对已存在的字段，进行替换；对未存在的字段，进行新增；

  4. 对于要校验的返回值进行断言处理。

     > 断言设置不仅要设置改动点的返回，还要设置涉及到改动点的返回是否符合预期，出问题才能定位的比较准确。
  
* pytest框架

  * 自动化测试脚本一般由**测试的输入、业务逻辑、测试输出和测试结果验证**几部分组成。
  * 在excel中输入请求的地址、方法、common参数、校验返回的断言等，一些私参不输入具体值，用占位符表示
  * 通过请求数据构造的服务器获得私参值
  * 在代码中使用pytest.mark.parametrize装饰器将case导入，与之前获取的私参值一起通过request这个模块请求测试环境的服务器，获得接口返回
  * 校验返回的参数

  > request模块
  >
  > ```python
  > res = requests.request(
  >     method=case['METHOD'],
  >     url=get_sim_domain(ENV) + case['URL'],
  >     params=json2dict(case['PARAMS']),
  >     # headers=json2dict(case['HEADERS']),
  >     data=json2dict(case['DATA']),
  >     json=json2dict(case['JSON'])).json()
  > ```

# 项目总结

## 项目介绍

**要解决的问题**：在固定网络规模（节点数、节点度）的前提下，通过使用深度强化学习来训练出优秀的模型，从而可以在面对一定流量强度下的业务时，快速的找到最优网络拓扑，以最大化的降低网络延迟。

**强化学习的原理**：强化学习强调如何基于环境来选择行为，以取得最大化的预期利益。强化学习其实是在环境和机器人之间的互动，环境通过对机器人产生奖励，刺激机器人根据当前的状态和奖励产生下一个动作，以获得更高的奖励为目的，如此不断进行下去。
就好比你在品尝一个没有吃过的食物，吃完之后你会对这个食物有一个判断，好吃或者不好吃，这种判断就是一个奖励，决定了你下一次面对这个食物时选择吃与不吃。

**强化学习在项目中的应用**：在这个项目中，使用agent与它的环境（即网络）通过状态、行为、奖励这三种信号来进行交互，agent的实现就是使用强化学习算法与深度神经网络结合的框架，其目的是找到最优的行为策略（网络拓扑矩阵），以最大化奖励（即最小化网络延迟）。具体在算法中它通过使用两个深度神经网络（Acotr、Critic）来迭代地改进选择动作的策略，已达到最大化奖励的目的。

**实际中的实现**：通过SDN控制器交换状态、动作和奖励，SD-DCN的数据平面采用光电混合交换框架，其中机架顶部(ToR)开关采用电链路连接形成固定的环形拓扑，同时使用光链路连接到多个光电路交换(OCS)开关。通过重新配置OCS交换机，可以实现不同的互连拓扑，以满足不同应用程序的不同通信需求。SDN控制器被部署用于集中的网络控制和管理。具体来说，状态由拓扑邻接矩阵的一半组成，通过数据处理成一维矩阵的形式，动作以拓扑邻接矩阵形式表示，奖励为平均网络延迟。

## 我的贡献

1. 强化学习中训练集的设计与实现
利用算法生成了符合要求的训练集，借鉴了Google DeepMind对于解决推荐系统在大规模离散空间下训练问题的方法，采用了k近邻
算法及贪婪策略进行训练集的分类与选取，并输入到神经网络进行训练；
2. 动态拓扑的设计
  在仿真初始环境中搭建全连接的网络拓扑，通过读取强化学习训练中产生的拓扑邻接矩阵来决定节点链路连接的通断以实现构建不同
  的网络拓扑环境；
3. 模型的训练与测试
  * 在不同流量下(25%、50%、75%...)分别训练模型，其网络时延平均值整体均随训练时间的增加呈逐步降低趋势，最后基本趋于稳定达到收敛；
  * 将训练模型分别与采用随机和贪婪策略生成拓扑的模型进行对比，在降低时延方面呈现出明显优越性；
  * 训练后的模型在面对新流量时可以一步输出相对稳定的近似最优拓扑矩阵。

# Python相关

## 数据类型

### 基本数据类型

数字int、布尔值bool、字符串str、列表list、元组tuple、字典dict等

### 列表和元组的区别

* 列表是动态数组，它们不可变且可以重设长度(改变其内部元素的个数)。
* 元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。

### 数组和链表的区别

数组：连续、顺序存储

> 在Python语言中，没有直接使用数组这个概念，而是用**列表(list)**和**元组(tuple)**这两种集合，它们本质上都是对数组的封装。
>
> 其中**列表**是一个**动态可扩展**的数组，支持任意的添加、删除、修改元素；
> 而**元组**是一个**不可变**集合，一旦创建就不再支持修改。s

链表：非连续、非顺序存储

**时间复杂度**

|      | 查找 | 更新 | 插入 | 删除 |
| ---- | ---- | ---- | ---- | ---- |
| 数组 | O(1) | O(1) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(1) |

### 可变类型和不可变类型

* 可变类型（mutable）：列表，字典
* 不可变类型（unmutable）：数字，字符串，元组

这里的可变不可变，是指**内存中的那块内容（value）是否可以被改变**。
如果是不可变类型，在对对象本身操作的时候，必须在内存中新申请一块区域(因为老区域不可变)。
如果是可变类型，对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的address会保持不变，但区域会变长或者变短。

不可变类型有什么好处？
如果数据是不可变类型，当我们把数据传给一个不了解的API时，可以确保我们的数据不会被修改。

### 可变参数(*args, **kargs)

* ***args**：是一个**元组**，传入的参数会被放进**元组**里。
* ***\*kwargs**：是一个**字典**，传入的参数以键值对的形式存放到**字典**里。

## 深拷贝和浅拷贝

* 深拷贝
  * 创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）
* 浅拷贝
  * 创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）

## 垃圾回收机制

* 对象的引用计数

  * Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
    * 引用计数增加的情况：
      * 一个对象分配一个新名称
      * 将其放入一个容器中（如列表、元组或字典）

    * 引用计数减少的情况：
      * 使用del语句对对象别名显示的销毁
      * 引用超出作用域或被重新赋值

## 读写文件

```python
# 按行读取文件
with open('log.txt', 'r') as f:
    for line in f:
        print(line, end='')

# 转换为列表，去掉换行符，去掉行首行尾的空白字符
with open('log.txt', 'r') as f:
    content = [line.strip() for line in f]
    # f.read().splitlines() 可去掉换行符，不可去掉空白字符
    print(content)

# 按行读取文件内容并得到当前行号
'''
文件对象是可迭代的（按行迭代），使用enumerate()即可在迭代的同时，得到数字索引(行号),
enumerate()的默认数字初始值是0，如需指定1为起始，可以设置其第二个参数为1。
'''
with open('log.txt', 'r') as f:
    for number, line in enumerate(f, start=1):
        print(number, line, end='')
```

```python
'''
读取日志文件，搜索关键字，打印关键字前5行
'''
def search(lines, pattern, history=5):
    previous_lines = []
    for line in lines:
        if len(previous_lines) < history and pattern in line:
            previous_lines.append(line)
    return previous_lines

if __name__ == '__main__':
    with open('log.txt', 'r') as f:
        # 去掉换行符
        f = f.read().splitlines()
        print(search(f, 'response'))

        # 追加
        f.write('\n... and more')
        print(open('log.txt').read())
```

## lambda函数

通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。

* 定义lambda函数的形式如下：

  * labmda 参数：表达式lambda函数默认返回表达式的值。

  * ```python
    # lambda [arguments]:expression
    a = lambda x,y:x+y
    ```

* lambda函数也可以赋值给一个变量。

* lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。

## 装饰器

参考：

https://www.zhihu.com/question/26930016
https://www.zhihu.com/question/26930016/answer/1047233982

## yield用法

参考：

https://blog.csdn.net/mieleizhi0522/article/details/82142856/
https://www.runoob.com/w3cnote/python-yield-used-analysis.html

# HTTP

HTTP 是**超文本传输协议** ，是一个在计算机世界里专门在**「两点」**之间**「传输」**文字、图片、音频、视频等**「超文本」**数据的**「约定和规范」**。

## get 和 post 的区别

- `Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。
  
> 比如，你打开一篇文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。

  

- `POST` 方法则是相反操作，它**向 `URI` 指定的资源提交数据**，数据就放在报文的 body 里。

  > 比如，你在一篇文章底部，敲入了留言后点击「提交」，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

## 状态码

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

> 常见错误码：
>
> 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
>
> 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
>
> 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
>
> ---
>
> 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
>
> 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
>
> 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
>
> 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

## HTTP与HTTPS

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了**加密（防窃听）**、**认证（防伪装）**和**完整性保护（防篡改）**。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh00tknagnj30un09l0uo.jpg" alt="img" style="zoom:50%;" />

> HTTP端口 80
> HTTPS端口443

### HTTP/HTTPS区别

1. 建立连接时候：https 比 http多了 TLS 的握手过程；
2. 传输内容的时候：https 会把数据进行加密，通常是对称加密数据；

### 加密

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;

- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh00y6wxjlj30u02650vm.jpg" alt="img" style="zoom: 25%;" />

### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh02s7vdgtj30m80gjdgw.jpg" alt="img" style="zoom:60%;" />

### 完整性保护

SSL 提供报文**摘要功能**来进行完整性保护。

## 输入一个网址到显示网页的过程

1. 在客户端浏览器中输入网址URL；
2. 发送到DNS(域名服务器)获得域名对应的WEB服务器的IP地址；
3. 客户端浏览器与WEB服务器建立TCP(传输控制协议)连接；
4. 客户端浏览器向对应IP地址的WEB服务器发送相应的HTTP或HTTPS请求；
5. WEB服务器响应请求，返回指定的URL数据或错误信息；
6. 客户端浏览器下载数据，解析HTML源文件，解析完成后，在浏览器中显示基础的页面；
7. 分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh02j2a8v6j30fy0cidjh.jpg" alt="image-20200722212545866" style="zoom: 80%;" />

### DNS域名系统工作原理

1. 查询浏览器、操作系统**缓存**；
2. 请求**本地域名服务器**；
3. 本地域名服务器未命中缓存，其请求**根域名服务器**；
4. 根域名服务器返回所查询域的**主域名服务器**（主域名、顶级域名，如com、cn）；
5. 本地域名服务器请求主域名服务器，获取该域名的 **名称服务器**（域名注册商的服务器）；
6. 本地域名服务器向 名称服务器 请求 **域名-IP 映射**；
7. 缓存解析结果。

### 客户端向服务器发起http请求时的请求信息

1. 请求方法URI协议/版本
2. 请求头(有关的客户端环境和请求正文的有用信息)
3. 请求正文(客户提交的查询字符串信息：)

##Cookie、Session

* Cookie保存在**客户端浏览器**中，而Session保存在**服务器**上。
* Cookie机制是通过检查客户身上的**“通行证”**来确定客户身份，Session机制是通过检查服务器上的**“客户明细表”**来确认客户身份。

## 短连接、长连接

* 短连接
  * 连接->传输数据->关闭连接 
  * HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
* 长连接
  * 连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接
  * 多是客户端关闭连接

# MySQL

## 使用的索引

* Hash索引
  * 底层原理：哈希表
* B+树索引
  * 底层原理：多路平衡查找树

## 事务

### 定义

一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务)。

### 事务四大特征(ACID)

* 原子性(A)：事务是最小单位，不可再分。
* 一致性(C)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败。
* 隔离性(I)：事务A和事务B之间具有隔离性。
* 持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)。

### 事务提交

`commit;`(让虚拟的效果真实产生)

### 事务手动回滚

`rollback;`（让虚拟的效果撤销）

### 事务的隔离性

* read uncommitted
  * 读未提交的
  * A事务已执行，但未提交；B事务查询到A事务的更新后数据；A事务回滚；---出现脏数据
* read committed
  * 读已经提交的
  * A事务执行更新；B事务查询；A事务又执行更新；B事务再次查询时，前后两次数据不一致；---不可重复读
* repeatable read
  * 可重复读
  * A事务无论执行多少次，只要不提交，B事务查询值都不变；B事务仅查询B事务开始时那一瞬间的数据快照。
* serializable
  * 串行化
  * 不允许读写并发操作，写执行时，读必须等待。

> mysql默认隔离级别是repeatable read

## 三大设计范式

* 第一范式：数据中所有字段都是不可分割的原子值。
* 第二范式：必须满足第一范式的前提下，除主键外的每一列都必须完全依赖于主键。
* 第三范式：必须满足第二范式，除主键列外的其他列之间不能有传递依赖关系。

> 数据库主键，指的是一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性。
> 主键主要是用与其他表的外键关联，以及本记录的修改与删除。

## 查询

### 连接查询

* 内连接

  * inner join 或者 join
  * 两张表中的数据，通过某个字段相等，查询出相关记录数据，用 on… 表示条件。

  ![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh0088pu9mj30640340sj.jpg)

* 外连接

  * 左连接：left join

    * 会把左边表里面的所有数据取出来，而右边表数据如果有相等的，就显示出来，如果没有，就补 NULL。

      ![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh008kq78sj307l032744.jpg)

  * 右连接：right join

    * 会把右边表里面的所有数据取出来，而左边表数据如果有相等的，就显示出来，如果没有，就补 NULL。

    ![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh008oukaej306g0393yb.jpg)

### 查询语句的执行顺序

* 查询语句书写顺序：select-from-where-group by-having-order by-limit

* 查询语句执行顺序：from-where-group by-having-select-order by-limit

> from：决定从哪儿获取数据
> where，group by，having：决定决定显示那几行
> select：决定显示的列
> order by：对列进行排序
> limit：决定获取哪些数据

### 面试题

- 学生表student(id,name)
- 课程表course(id,name)
- 学生课程表student_course(sid,cid,score)

1. 查询student表中重名的学生，结果包含id和name，按name,id升序。

   * 需要查询某一列重复的行，一般通过**group by**(有重复的列)然后取**count>1**的值。 

   * **order by** 默认升序排列

     ```mysql
     select id, name from student where name in (
       select name from student group by name	# 分组
     having count(*) > 1	#条件
     ) order by name;
     ```
     

   > count(*)
   > 返回表中的记录数(包括所有列)，相当于**统计表的行数**(不会忽略列值为NULL的记录)
   >
   > count(1)
   > 忽略所有列，1表示一个固定值，也可以用count(2)、count(3)代替(不会忽略列值为NULL的记录)
   >
   > count(列名)
   > 返回列名指定列的记录数，列值为NULL的记录不统计在内。
   >
   > count(distinct 列名)
   > 只包括列名指定列，返回指定列的**不同值**的记录数，列值为NULL的记录不统计在内。

   

2. 在student_course表中查询平均分不及格的学生，列出学生id和平均分。

   * **where子句中不能用聚合函数作为条件表达式，但是having短语可以**；

      > where后面之所以不能使用聚合函数是因为**where的执行顺序在聚合函数之前**：
      >
      > ```mysql
      > select sum(score) from student group by student.sex where sum(student.age)>100;  # wrong
      > ```
      >
      > **having是对查出来的结果进行过滤**，那么就不能对没有查出来的值使用having： 
      >
      > ```mysql
      > select student.id,student.name from student having student.score >90; 	# wrong
      > ```

   * **where只能写在group by前边，要想在后边加限制条件，应该使用having关键字。**

      ```mysql
     select sid, avg(score) as avg_score from student_course group by sid 
     	having avg_score < 60;
     ```

   > **聚合函数是用来做纵向运算的函数**
   >
   > count()：统计指定列不为null的记录行数。
   > max()：  计算指定列的最大值
   > min()：  计算指定列的最小值
   > sum()： 计算指定列的数值和
   > avg()：  计算指定列的平均值
   >
   > **注：凡是和聚合函数同时出现的列名，则一定要写在group by之后。**

   

3. 在student_course表中查询每门课成绩都不低于80的学生id。

   * ```mysql
     select distinct sid from student_cource where sid in(
       select sid from student_cource where score > 80);
     ```

4. 总成绩最高的学生，结果列出学生id和总成绩。

   * **order by、limit**

     ```mysql
     select sid, sum(score) as sum_score from student_cource group by sid 
     	order by sum_score desc limit 1;
     ```

   > limit用来限制查询结果的起始行，以及总行数.

   

5. 在student_course表查询课程1成绩第2高的学生，如果第2高的不止一个则列出所有的学生。

   * 查询 **第N大数** 的问题

     ```mysql
     select * from student_course where cid = 1 and score = (
       # 查出第2高的成绩
       select score from student_course where cid = 1 group by score order by score desc limit 1, 1);
     ```

## MySQL与Redis的区别

* 类型上
  * 从类型上来说，mysql是关系型数据库，redis是缓存数据库。

* 作用上
  * mysql用于持久化的存储数据到**硬盘**，功能强大，但是读取速度较慢。
  * redis用于存储使用较为频繁的数据到**缓存**中，读取速度快。

# 计算机网络

## 计算机网络体系结构

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh02rwaro2j30k60gi0tc.jpg" alt="img" style="zoom:50%;" />

* 每一层的作用：
  * 物理层：通过媒介传输比特，确定机械及电气规范（比特Bit）（中继器，集线器，网关）
  * 数据链路层：将比特封装成帧和点到点的传递（帧Frame）（网桥，交换机）
  * 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）（路由器）
    * 协议：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP
  * 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    * 协议：TCP、UDP
  * 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    * 协议：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

## TCP三次握手

### 过程

假设 A 为客户端，B 为服务器端。

1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求；
2. A 向 B 发送连接请求报文；
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文；
4. A 收到 B 的连接确认报文后，还要向 B 发出确认；
5. B 收到 A 的确认后，连接建立。

### 三次握手的原因

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## TCP四次挥手

### 过程

1. A 发送连接释放报文；
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
3. 当 B 不再需要连接时，发送连接释放报文；
4. A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接；
5. B 收到 A 的确认后释放连接。

### 四次挥手的原因

客户端发送了连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

#### 为什么要TIME_WAIT

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## TCP和UDP的区别

1. TCP面向连接，UDP无连接；
2. TCP开销比UDP小；
3. TCP提供可靠的服务，UDP不保证可靠交付；
4. 每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。

## TCP如何保证数据的可靠传输

4种拥塞控制算法：慢启动，拥塞避免，快速重传和快速恢复。

1. 针对数据包丢失或者出现的定时器**超时重传**机制；
2. 针对数据包到达接收端主机顺序乱掉的顺序控制、对失序**数据进行重新排序**，然后才交给应用层；
3. 针对高效传输数据包的**流动窗口控制**；
4. 针对避免网络拥堵时候的**流量控制**；
5. 针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的**慢启动算法**和**拥塞控制**。

# 操作系统

## 进程间通信的方式

* 消息传递（管道、消息队列、FIFO）
* 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
* 共享内存（匿名的和具名的，eg:channel）
* 远程过程调用(RPC)

## 进程和线程

- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，**进程是系统进行资源分配和调度的一个独立单位**。
- **线程是进程的一个实体，是CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位。

### 进程和线程的关系

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。**线程是操作系统可识别的最小执行和调度单位**。
- 资源分配给**进程**，同一进程的所有线程**共享**该进程的所有资源。
- 真正在处理机上运行的是**线程**。
- 线程在执行过程中，需要协作同步。不同进程的线程间要利用**消息通信**的办法实现同步。

### 进程和线程的区别

- 进程有自己的独立**地址空间**，线程没有；
- 进程是**资源分配**的最小单位，线程是**CPU调度**的最小单位；
- 进程和线程通信方式不同；
  - **同一进程下的线程共享数据**(比如全局变量，静态变量)，线程通过这些数据来通信；
  - 而进程之间的通信只能通过**进程通信**的方式进行。
- 进程上下文切换**开销大**，线程**开销小**；
- 一个进程挂掉了**不会影响**其他进程，而线程挂掉了**会影响**其他线程；

## 死锁

* 死锁概念及产生原理
  * 概念：多个并发进程因争夺系统资源而产生相互等待的现象。
  * 原理：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。

   **本质原因：**

​	1）系统资源有限。

​	2）进程推进顺序不合理。

* 死锁产生的4个必要条件

  1. 互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。

  2. 占有且等待：一个进程本身占有资源(一种或多种)，同时还有资源未得到满足，正在等待其他进程释放该资源。

    3. 不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。

  4. 循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

## 并行 & 并发

* 并发（Concurrent），在操作系统中，是指**一个时间段中**有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。

* 并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以**同时**进行，这种方式我们称之为并行(Parallel)。

> 并发的关键是你有处理多个任务的能力，不一定要同时。
> 并行的关键是你有同时处理多个任务的能力。
>
> 所以我认为它们最关键的点就是：是否是**『同时』**。

![img](https://img2018.cnblogs.com/blog/1628624/201905/1628624-20190505161932608-1136050215.jpg)

# Linux

## 查看端口状态

* 查看哪些端口被打开：`netstat -anp`

* 关闭某个端口：`kill -9 PID` (PID：进程号)

  ```sh
  # 例如要关闭22号端口：
  
  $ netstat -anp | grep :22
  # 返回
  tcp 0  0 0.0.0.0:22   0.0.0.0:*  LISTEN  988/sshd
  
  # 如此，知道了22号端口对应的进程ID 988，只要kill掉该进程即可关闭该端口：
  $ kill 988
  ```

## 查看进程

`ps`：当前进程情况

`top：`实时查看进程

## 查找

### 查找文件

1. 命令格式
find [查找目录] [查找规则] [查找完后的操作]
即：find pathname -option [-print -exec -ok …]

2. 命令功能
用于在文件树中查找文件，并做相应的处理，(有可能访问磁盘)。

3. 命令参数
  （1）pathname：表示所要查找的目录路径,例如”.”表示当前目录，”/”表示根目录。
  （2）-print：将find找到的文件输出到标准输出。
  （3）-exec：对找到的文件执行exec这个参数所指定的shell命令，相应的形式为：-exec command {} \; 

  ​					  将查到的文件进行command操作，”{}”就代替查到的文件。

```shell
find . -name My_Work
```

### 查找关键字

参考：https://linux.cn/article-1672-1.html

## 修改权限

`chmod`

`chmod 777`：所有用户都可读可写可执行

## 修改文件内容

```shell
# 将log.txt中的response替换成request
sed -i "" 's/response/request/g' log.txt
```

# 补充

## Nginx

### 什么是Nginx?

Nginx是一个web服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。

### 反向代理服务器是什么?

我们访问互联网上的服务时，大多数时，客户端并不是直接访问到服务端的，而是客户端首先请求到反向代理，反向代理再转发到服务端实现服务访问，通过反向代理实现路由/负载均衡等策略。这样在服务端拿到的客户端IP将是反向代理IP，而不是真实客户端IP，因此需要nginx反向代理实现获取用户真实ip

```nginx
# 客户端访问服务端的数据流走向
client(172.25.0.1) --> ADSL(192.168.0.1)--> cdn(10.0.0.1) --> SLB(反向代理)11.0.0.1 --> server(nginx)12.0.0.1
```

反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层，提高了安全性。

### Nginx如何处理HTTP请求？

Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。

# 面试模拟

1. 自我介绍

2. 介绍一下实验室的项目，你都做了什么？

3. 介绍一下实习的项目，你都做了什么？

4. 测试流程、测试方法？

5. 自动化测试的流程、case如何编写？

   ...

